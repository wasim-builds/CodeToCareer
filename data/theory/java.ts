import { TheoryTopic } from '@/types/theory';

export const javaTheory: TheoryTopic = {
  topicId: 'java',
  topicName: 'Java',
  category: 'Languages',
  description: 'Java programming language and object-oriented concepts',
  sections: [
    {
      id: 'basics',
      title: 'Java Basics',
      content: '',
      subsections: [
        { id: 'q1', title: 'What is Java and its key features?', content: 'Java is an object-oriented, platform-independent programming language. Key features: Write Once, Run Anywhere (WORA) via JVM, automatic memory management (garbage collection), strong type system, multi-threading support, and extensive standard library. Java is compiled to bytecode that runs on JVM.' },
        { id: 'q2', title: 'What is JVM, JRE, and JDK?', content: 'JVM (Java Virtual Machine) executes bytecode. JRE (Java Runtime Environment) includes JVM and libraries needed to run Java programs. JDK (Java Development Kit) includes JRE plus development tools (compiler, debugger, etc.). JDK is needed for development, JRE for running applications.' },
        { id: 'q3', title: 'What are Java\'s primitive data types?', content: 'Java has 8 primitives: byte (8-bit), short (16-bit), int (32-bit), long (64-bit), float (32-bit), double (64-bit), char (16-bit Unicode), boolean (true/false). Primitives are stored on the stack, while objects are stored on the heap.' },
        { id: 'q4', title: 'What is the difference between == and equals()?', content: '== compares references for objects (memory addresses) or values for primitives. equals() compares object content/values. For String, equals() compares character sequences, while == compares references. Always use equals() for object comparison, == for primitives.' },
        { id: 'q5', title: 'What is String immutability?', content: 'Strings in Java are immutable - once created, they cannot be changed. Operations like concat() or substring() return new String objects. This ensures thread safety and security. StringBuffer and StringBuilder are mutable alternatives for string manipulation.' },
        { id: 'q6', title: 'What is the difference between String, StringBuffer, and StringBuilder?', content: 'String is immutable and thread-safe. StringBuffer is mutable and thread-safe (synchronized). StringBuilder is mutable and not thread-safe (faster). Use String for constants, StringBuffer for multi-threaded environments, StringBuilder for single-threaded string manipulation.' },
        { id: 'q7', title: 'What are Java access modifiers?', content: 'Four access levels: public (accessible everywhere), protected (package + subclasses), default/package-private (same package only), private (same class only). They control encapsulation and visibility of classes, methods, and variables.' },
        { id: 'q8', title: 'What is a Java package?', content: 'A package is a namespace that organizes related classes and interfaces. It prevents naming conflicts and provides access control. Package declaration uses package keyword. Import statements bring classes into scope. Java has built-in packages (java.lang, java.util) and allows custom packages.' },
        { id: 'q9', title: 'What is static in Java?', content: 'static keyword means the member belongs to the class rather than instances. Static variables are shared across all instances. Static methods can be called without creating objects. Static blocks execute when class is loaded. Cannot use this or super in static context.' },
        { id: 'q10', title: 'What is final in Java?', content: 'final keyword prevents modification: final variables cannot be reassigned, final methods cannot be overridden, final classes cannot be extended. final variables must be initialized. Used for constants, immutability, and preventing inheritance/overriding.' }
      ]
    },
    {
      id: 'oop',
      title: 'Object-Oriented Programming',
      content: '',
      subsections: [
        { id: 'q11', title: 'What is a class and object?', content: 'A class is a blueprint/template that defines attributes (fields) and behaviors (methods). An object is an instance of a class created using the new keyword. Objects have state (field values) and behavior (methods). Classes define what objects can do.' },
        { id: 'q12', title: 'What is a constructor?', content: 'A constructor initializes objects when created. It has the same name as the class and no return type. Default constructor is provided if none defined. Can be overloaded with different parameters. Constructor chaining uses this() to call another constructor.' },
        { id: 'q13', title: 'What is inheritance?', content: 'Inheritance allows a class (subclass) to inherit fields and methods from another class (superclass). Uses extends keyword. Supports code reuse and IS-A relationship. Java supports single inheritance for classes, multiple inheritance for interfaces. super keyword accesses parent class members.' },
        { id: 'q14', title: 'What is method overriding?', content: 'Method overriding occurs when a subclass provides a specific implementation of a method defined in the superclass. Method signature must match. @Override annotation ensures correct overriding. Runtime polymorphism is achieved through overriding. Cannot override static, final, or private methods.' },
        { id: 'q15', title: 'What is method overloading?', content: 'Method overloading allows multiple methods with the same name but different parameters (number, type, or order). Methods must differ in signature. Return type alone doesn\'t differentiate overloaded methods. Compile-time polymorphism. Useful for providing multiple ways to call a method.' },
        { id: 'q16', title: 'What is polymorphism?', content: 'Polymorphism means "many forms" - same interface, different implementations. Two types: compile-time (method overloading) and runtime (method overriding). Runtime polymorphism uses method overriding and allows a reference variable to refer to different object types.' },
        { id: 'q17', title: 'What is abstraction?', content: 'Abstraction hides implementation details and shows only essential features. Achieved through abstract classes (abstract keyword) and interfaces. Abstract classes can have both abstract and concrete methods. Interfaces define contracts that implementing classes must fulfill.' },
        { id: 'q18', title: 'What is an abstract class?', content: 'An abstract class cannot be instantiated and may contain abstract methods (without body). Defined with abstract keyword. Can have concrete methods and fields. Subclasses must implement all abstract methods or be abstract themselves. Used to provide common functionality while requiring specific implementations.' },
        { id: 'q19', title: 'What is an interface?', content: 'An interface defines a contract - methods that implementing classes must provide. All methods are public and abstract (implicitly). Can have constants (public static final). Java 8+ allows default and static methods. A class can implement multiple interfaces. Used for achieving abstraction and multiple inheritance.' },
        { id: 'q20', title: 'What is encapsulation?', content: 'Encapsulation bundles data and methods together and restricts direct access. Achieved by making fields private and providing public getter/setter methods. Protects data integrity and allows controlled access. Follows "data hiding" principle. Enables validation and modification of internal representation without affecting external code.' }
      ]
    },
    {
      id: 'collections',
      title: 'Collections Framework',
      content: '',
      subsections: [
        { id: 'q21', title: 'What is the Collections Framework?', content: 'Collections Framework provides classes and interfaces for storing and manipulating groups of objects. Main interfaces: Collection (root), List, Set, Queue, Map. Provides implementations like ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap. Reduces programming effort and increases performance.' },
        { id: 'q22', title: 'What is the difference between List and Set?', content: 'List is ordered, allows duplicates, indexed access. Set is unordered (or sorted), no duplicates, no index. List implementations: ArrayList, LinkedList, Vector. Set implementations: HashSet, LinkedHashSet, TreeSet. Use List for ordered collections with duplicates, Set for unique elements.' },
        { id: 'q23', title: 'What is ArrayList vs LinkedList?', content: 'ArrayList uses dynamic array, provides fast random access (O(1)), slower insertions/deletions (O(n)). LinkedList uses doubly-linked list, slower random access (O(n)), faster insertions/deletions (O(1)). Use ArrayList for frequent access, LinkedList for frequent modifications.' },
        { id: 'q24', title: 'What is HashMap?', content: 'HashMap stores key-value pairs, allows one null key and multiple null values, not synchronized, not ordered. Uses hashing for fast access (O(1) average). Keys must implement hashCode() and equals(). Not thread-safe. Use ConcurrentHashMap for thread-safe operations.' },
        { id: 'q25', title: 'What is the difference between HashMap and Hashtable?', content: 'HashMap is not synchronized (faster, not thread-safe), allows one null key, part of Collections Framework. Hashtable is synchronized (thread-safe, slower), doesn\'t allow null keys/values, legacy class. Prefer HashMap with external synchronization or ConcurrentHashMap for thread safety.' },
        { id: 'q26', title: 'What is TreeMap?', content: 'TreeMap implements NavigableMap, stores key-value pairs in sorted order (natural or custom comparator), provides guaranteed log(n) time cost for operations. Keys must be Comparable or provide Comparator. Maintains ascending key order. Slower than HashMap but provides sorted iteration.' },
        { id: 'q27', title: 'What is HashSet?', content: 'HashSet implements Set interface, stores unique elements using hashing, allows one null value, not ordered, not synchronized. Backed by HashMap. Fast add, remove, contains operations (O(1) average). Elements must implement hashCode() and equals(). Use for unique element storage.' },
        { id: 'q28', title: 'What is Iterator?', content: 'Iterator is an interface for traversing collections. Methods: hasNext() (checks if more elements), next() (returns next element), remove() (removes current element). Allows safe iteration and modification during traversal. Enhanced for-loop uses Iterator internally. Prevents ConcurrentModificationException when used correctly.' },
        { id: 'q29', title: 'What is Comparable vs Comparator?', content: 'Comparable interface defines natural ordering (compareTo method), implemented by the class itself. Comparator interface defines custom ordering (compare method), separate class. Comparable for single natural order, Comparator for multiple sorting criteria. Collections.sort() uses Comparable, Collections.sort(list, comparator) uses Comparator.' },
        { id: 'q30', title: 'What are generics?', content: 'Generics provide type safety by allowing type parameters. Syntax: ClassName<T>. Prevents ClassCastException at compile-time. Enables code reuse with type safety. Can use wildcards (? extends Type, ? super Type) for flexibility. Eliminates need for casting and provides better code readability.' }
      ]
    },
    {
      id: 'exceptions',
      title: 'Exception Handling',
      content: '',
      subsections: [
        { id: 'q31', title: 'What is exception handling?', content: 'Exception handling manages runtime errors gracefully. Uses try-catch-finally blocks. try contains code that might throw exceptions, catch handles specific exceptions, finally always executes (cleanup). Prevents program crashes and allows error recovery. Java has checked (compile-time) and unchecked (runtime) exceptions.' },
        { id: 'q32', title: 'What is the difference between checked and unchecked exceptions?', content: 'Checked exceptions extend Exception (not RuntimeException), must be handled or declared (throws), compile-time checking. Unchecked exceptions extend RuntimeException, not required to handle, runtime checking. Checked: IOException, SQLException. Unchecked: NullPointerException, ArrayIndexOutOfBoundsException.' },
        { id: 'q33', title: 'What is throw vs throws?', content: 'throw is a statement that explicitly throws an exception within a method. throws is a keyword in method signature declaring that the method may throw exceptions. throw creates exception, throws declares it. Method with throws must be called in try-catch or have throws in caller.' },
        { id: 'q34', title: 'What is finally block?', content: 'finally block always executes regardless of exception occurrence. Used for cleanup (closing files, connections). Executes even if return statement is in try/catch. Only System.exit() prevents finally execution. Can have try-finally without catch. Useful for resource management.' },
        { id: 'q35', title: 'What is try-with-resources?', content: 'try-with-resources (Java 7+) automatically closes resources implementing AutoCloseable. Syntax: try (ResourceType resource = new ResourceType()) {}. Resources are closed in reverse order. Prevents resource leaks. Replaces manual finally blocks for resource management. Cleaner and safer than manual close().' },
        { id: 'q36', title: 'What are common exceptions?', content: 'NullPointerException: accessing null reference. ArrayIndexOutOfBoundsException: invalid array index. ClassCastException: invalid type casting. IllegalArgumentException: invalid method argument. IllegalStateException: invalid object state. IOException: I/O operation failure. These are common runtime exceptions to handle.' },
        { id: 'q37', title: 'What is exception hierarchy?', content: 'Throwable is the root class. Two subclasses: Error (serious, not recoverable, e.g., OutOfMemoryError) and Exception. Exception has two types: RuntimeException (unchecked) and other exceptions (checked). Custom exceptions extend Exception or RuntimeException. Follow naming convention: *Exception suffix.' },
        { id: 'q38', title: 'What is custom exception?', content: 'Custom exceptions are user-defined exception classes extending Exception or RuntimeException. Provide meaningful names ending with Exception. Can add custom fields and methods. Checked exceptions extend Exception, unchecked extend RuntimeException. Used for domain-specific error handling and better error messages.' },
        { id: 'q39', title: 'What is exception propagation?', content: 'Exception propagation is when an exception moves up the call stack if not caught. Unchecked exceptions automatically propagate. Checked exceptions propagate if declared in throws. Propagation continues until caught or reaches main() (program terminates). Use throws to propagate, catch to handle.' },
        { id: 'q40', title: 'What is exception handling best practice?', content: 'Catch specific exceptions, don\'t catch Exception/Throwable. Use try-with-resources for AutoCloseable. Don\'t suppress exceptions silently. Provide meaningful error messages. Log exceptions appropriately. Clean up resources in finally. Don\'t catch and ignore. Use custom exceptions for domain errors. Handle at appropriate level.' }
      ]
    },
    {
      id: 'multithreading',
      title: 'Multithreading and Concurrency',
      content: '',
      subsections: [
        { id: 'q41', title: 'What is multithreading?', content: 'Multithreading allows concurrent execution of multiple threads within a process. Threads share process memory but have separate call stacks. Java supports multithreading through Thread class and Runnable interface. Enables better CPU utilization and responsive applications. Threads can run in parallel on multi-core systems.' },
        { id: 'q42', title: 'What is the difference between Thread and Runnable?', content: 'Thread is a class that extends Thread and overrides run(). Runnable is an interface with single run() method. Prefer Runnable: Java doesn\'t support multiple inheritance, Runnable allows extending other classes, more flexible. Thread class also implements Runnable. Use ExecutorService for thread management.' },
        { id: 'q43', title: 'What is thread lifecycle?', content: 'Thread states: NEW (created, not started), RUNNABLE (executing), BLOCKED (waiting for monitor lock), WAITING (indefinite wait), TIMED_WAITING (timed wait), TERMINATED (completed). States transition via start(), sleep(), wait(), notify(), join(), etc. getState() returns current state.' },
        { id: 'q44', title: 'What is synchronization?', content: 'Synchronization prevents multiple threads from accessing shared resources simultaneously. Uses synchronized keyword on methods or blocks. Ensures thread safety and prevents race conditions. Only one thread can execute synchronized code at a time. Can cause deadlocks if not used carefully.' },
        { id: 'q45', title: 'What is deadlock?', content: 'Deadlock occurs when two or more threads are blocked forever, waiting for each other. Conditions: mutual exclusion, hold and wait, no preemption, circular wait. Prevention: avoid nested locks, use timeout, lock ordering. Detection and recovery mechanisms exist. Careful design prevents deadlocks.' },
        { id: 'q46', title: 'What is volatile keyword?', content: 'volatile ensures variable visibility across threads. Prevents compiler optimizations that cache variable values. Changes are immediately visible to all threads. Doesn\'t provide atomicity (use AtomicInteger, etc. for that). Useful for flags and simple shared state. Weaker than synchronization but faster.' },
        { id: 'q47', title: 'What is ExecutorService?', content: 'ExecutorService (java.util.concurrent) manages thread pools and execution. Provides submit() for task submission, shutdown() for graceful shutdown. Thread pools reuse threads, reducing overhead. Implementations: ThreadPoolExecutor, ScheduledThreadPoolExecutor. Better than manual thread management. Handles thread lifecycle automatically.' },
        { id: 'q48', title: 'What are concurrent collections?', content: 'Concurrent collections are thread-safe: ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue, etc. Provide better performance than synchronized collections. Use fine-grained locking or lock-free algorithms. ConcurrentHashMap allows concurrent reads and writes. Use instead of synchronized wrappers for better performance.' },
        { id: 'q49', title: 'What is wait(), notify(), and notifyAll()?', content: 'These are Object class methods for thread coordination. wait() makes thread wait until notified, releases lock. notify() wakes one waiting thread. notifyAll() wakes all waiting threads. Must be called within synchronized block. Used for producer-consumer patterns. Prefer higher-level concurrency utilities when possible.' },
        { id: 'q50', title: 'What is thread safety?', content: 'Thread safety means code works correctly when accessed by multiple threads simultaneously. Achieved through: synchronization, immutable objects, thread-local storage, atomic variables, concurrent collections. Immutable objects are inherently thread-safe. Design for thread safety from the start. Test thoroughly in concurrent scenarios.' }
      ]
    }
  ]
};
