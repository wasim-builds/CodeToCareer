#!/usr/bin/env python3
"""Script to add final 28 problems to problems.ts"""

# Read the file
with open('/home/wasim/Quiz App/CodeToCareer/data/practice/problems.ts', 'r') as f:
    content = f.read()

# Remove the closing '];' 
content = content.rstrip()
if content.endswith('];'):
    content = content[:-2]

# Add the final 28 problems (compact format)
final_problems = '''  },
  { id: 'number-of-islands', slug: 'number-of-islands', title: 'Number of Islands', difficulty: 'medium', topics: ['Graph', 'DFS', 'BFS'], prompt: 'Given an m x n 2D binary grid which represents a map of 1s (land) and 0s (water), return the number of islands.', constraints: ['m == grid.length', 'n == grid[i].length'], examples: [{ input: 'grid = [["1","1","0"],["1","1","0"],["0","0","1"]]', output: '2' }], hints: ['DFS/BFS from each unvisited land cell', 'Mark visited cells'], starterCode: [{ language: 'javascript', functionName: 'numIslands', code: 'function numIslands(grid) {\\n  return 0;\\n}\\n\\nmodule.exports = numIslands;' }, { language: 'typescript', functionName: 'numIslands', code: 'function numIslands(grid: string[][]): number {\\n  return 0;\\n}\\n\\nexport default numIslands;' }, { language: 'python', functionName: 'numIslands', code: 'def numIslands(grid):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { grid: [['1','1','0'],['1','1','0'],['0','0','1']] }, output: 2 }], solution: 'DFS/BFS from each 1, mark as visited, count islands.' },
  { id: 'clone-graph', slug: 'clone-graph', title: 'Clone Graph', difficulty: 'medium', topics: ['Graph', 'DFS', 'BFS'], prompt: 'Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.', constraints: ['The number of nodes in the graph is in the range [0, 100]'], examples: [{ input: 'adjList = [[2,4],[1,3],[2,4],[1,3]]', output: '[[2,4],[1,3],[2,4],[1,3]]' }], hints: ['Use HashMap to track cloned nodes', 'DFS/BFS to traverse'], starterCode: [{ language: 'javascript', functionName: 'cloneGraph', code: 'function cloneGraph(node) {\\n  return null;\\n}\\n\\nmodule.exports = cloneGraph;' }, { language: 'typescript', functionName: 'cloneGraph', code: 'function cloneGraph(node: Node | null): Node | null {\\n  return null;\\n}\\n\\nexport default cloneGraph;' }, { language: 'python', functionName: 'cloneGraph', code: 'def cloneGraph(node):\\n    return None' }], tests: [{ id: 's1', type: 'sample', input: { adjList: [[2,4],[1,3],[2,4],[1,3]] }, output: [[2,4],[1,3],[2,4],[1,3]] }], solution: 'HashMap + DFS: clone nodes, connect neighbors.' },
  { id: 'course-schedule', slug: 'course-schedule', title: 'Course Schedule', difficulty: 'medium', topics: ['Graph', 'Topological Sort'], prompt: 'There are numCourses courses labeled from 0 to numCourses - 1. Given prerequisites array, return true if you can finish all courses.', constraints: ['1 <= numCourses <= 2000'], examples: [{ input: 'numCourses = 2, prerequisites = [[1,0]]', output: 'true' }], hints: ['Detect cycle in directed graph', 'Use DFS with 3 states or Kahn algorithm'], starterCode: [{ language: 'javascript', functionName: 'canFinish', code: 'function canFinish(numCourses, prerequisites) {\\n  return false;\\n}\\n\\nmodule.exports = canFinish;' }, { language: 'typescript', functionName: 'canFinish', code: 'function canFinish(numCourses: number, prerequisites: number[][]): boolean {\\n  return false;\\n}\\n\\nexport default canFinish;' }, { language: 'python', functionName: 'canFinish', code: 'def canFinish(numCourses, prerequisites):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { numCourses: 2, prerequisites: [[1,0]] }, output: true }], solution: 'Topological sort: if cycle exists, return false.' },
  { id: 'longest-increasing-subsequence', slug: 'longest-increasing-subsequence', title: 'Longest Increasing Subsequence', difficulty: 'medium', topics: ['Array', 'DP', 'Binary Search'], prompt: 'Given an integer array nums, return the length of the longest strictly increasing subsequence.', constraints: ['1 <= nums.length <= 2500'], examples: [{ input: 'nums = [10,9,2,5,3,7,101,18]', output: '4' }], hints: ['DP: dp[i] = max LIS ending at i', 'Or binary search with patience sorting'], starterCode: [{ language: 'javascript', functionName: 'lengthOfLIS', code: 'function lengthOfLIS(nums) {\\n  return 0;\\n}\\n\\nmodule.exports = lengthOfLIS;' }, { language: 'typescript', functionName: 'lengthOfLIS', code: 'function lengthOfLIS(nums: number[]): number {\\n  return 0;\\n}\\n\\nexport default lengthOfLIS;' }, { language: 'python', functionName: 'lengthOfLIS', code: 'def lengthOfLIS(nums):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { nums: [10,9,2,5,3,7,101,18] }, output: 4 }], solution: 'DP O(nÂ²) or Binary Search O(n log n).' },
  { id: 'edit-distance', slug: 'edit-distance', title: 'Edit Distance', difficulty: 'hard', topics: ['String', 'DP'], prompt: 'Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. Operations: insert, delete, replace.', constraints: ['0 <= word1.length, word2.length <= 500'], examples: [{ input: 'word1 = "horse", word2 = "ros"', output: '3' }], hints: ['DP: dp[i][j] = min ops to convert word1[0:i] to word2[0:j]'], starterCode: [{ language: 'javascript', functionName: 'minDistance', code: 'function minDistance(word1, word2) {\\n  return 0;\\n}\\n\\nmodule.exports = minDistance;' }, { language: 'typescript', functionName: 'minDistance', code: 'function minDistance(word1: string, word2: string): number {\\n  return 0;\\n}\\n\\nexport default minDistance;' }, { language: 'python', functionName: 'minDistance', code: 'def minDistance(word1, word2):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { word1: 'horse', word2: 'ros' }, output: 3 }], solution: 'DP: if chars match, dp[i][j]=dp[i-1][j-1], else 1+min(insert,delete,replace).' },
  { id: 'word-ladder', slug: 'word-ladder', title: 'Word Ladder', difficulty: 'hard', topics: ['String', 'BFS', 'Graph'], prompt: 'Given two words beginWord and endWord, and a dictionary wordList, return the length of shortest transformation sequence from beginWord to endWord.', constraints: ['1 <= beginWord.length <= 10'], examples: [{ input: 'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]', output: '5' }], hints: ['BFS from beginWord', 'Try all 1-char transformations'], starterCode: [{ language: 'javascript', functionName: 'ladderLength', code: 'function ladderLength(beginWord, endWord, wordList) {\\n  return 0;\\n}\\n\\nmodule.exports = ladderLength;' }, { language: 'typescript', functionName: 'ladderLength', code: 'function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\\n  return 0;\\n}\\n\\nexport default ladderLength;' }, { language: 'python', functionName: 'ladderLength', code: 'def ladderLength(beginWord, endWord, wordList):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { beginWord: 'hit', endWord: 'cog', wordList: ['hot','dot','dog','lot','log','cog'] }, output: 5 }], solution: 'BFS: try all 1-char changes, track visited.' },
  { id: 'word-search', slug: 'word-search', title: 'Word Search', difficulty: 'medium', topics: ['Array', 'Backtracking'], prompt: 'Given an m x n grid of characters board and a string word, return true if word exists in the grid.', constraints: ['m == board.length', 'n = board[i].length'], examples: [{ input: 'board = [["A","B","C"],["S","F","C"],["A","D","E"]], word = "ABCCED"', output: 'true' }], hints: ['Backtrack from each cell', 'Mark visited, unmark on backtrack'], starterCode: [{ language: 'javascript', functionName: 'exist', code: 'function exist(board, word) {\\n  return false;\\n}\\n\\nmodule.exports = exist;' }, { language: 'typescript', functionName: 'exist', code: 'function exist(board: string[][], word: string): boolean {\\n  return false;\\n}\\n\\nexport default exist;' }, { language: 'python', functionName: 'exist', code: 'def exist(board, word):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { board: [['A','B','C'],['S','F','C'],['A','D','E']], word: 'ABCCED' }, output: true }], solution: 'DFS backtracking from each cell.' },
  { id: 'find-minimum-in-rotated-sorted-array', slug: 'find-minimum-in-rotated-sorted-array', title: 'Find Minimum in Rotated Sorted Array', difficulty: 'medium', topics: ['Array', 'Binary Search'], prompt: 'Suppose an array of length n sorted in ascending order is rotated. Find the minimum element.', constraints: ['n == nums.length', '1 <= n <= 5000'], examples: [{ input: 'nums = [3,4,5,1,2]', output: '1' }], hints: ['Binary search', 'Compare mid with right'], starterCode: [{ language: 'javascript', functionName: 'findMin', code: 'function findMin(nums) {\\n  return 0;\\n}\\n\\nmodule.exports = findMin;' }, { language: 'typescript', functionName: 'findMin', code: 'function findMin(nums: number[]): number {\\n  return 0;\\n}\\n\\nexport default findMin;' }, { language: 'python', functionName: 'findMin', code: 'def findMin(nums):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { nums: [3,4,5,1,2] }, output: 1 }], solution: 'Binary search: if nums[mid] > nums[right], min in right half.' },
  { id: 'median-of-two-sorted-arrays', slug: 'median-of-two-sorted-arrays', title: 'Median of Two Sorted Arrays', difficulty: 'hard', topics: ['Array', 'Binary Search'], prompt: 'Given two sorted arrays nums1 and nums2, return the median of the two sorted arrays.', constraints: ['nums1.length == m', 'nums2.length == n'], examples: [{ input: 'nums1 = [1,3], nums2 = [2]', output: '2.0' }], hints: ['Binary search on smaller array', 'Partition both arrays'], starterCode: [{ language: 'javascript', functionName: 'findMedianSortedArrays', code: 'function findMedianSortedArrays(nums1, nums2) {\\n  return 0.0;\\n}\\n\\nmodule.exports = findMedianSortedArrays;' }, { language: 'typescript', functionName: 'findMedianSortedArrays', code: 'function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\\n  return 0.0;\\n}\\n\\nexport default findMedianSortedArrays;' }, { language: 'python', functionName: 'findMedianSortedArrays', code: 'def findMedianSortedArrays(nums1, nums2):\\n    return 0.0' }], tests: [{ id: 's1', type: 'sample', input: { nums1: [1,3], nums2: [2] }, output: 2.0 }], solution: 'Binary search to partition arrays equally.' },
  { id: 'longest-substring-without-repeating', slug: 'longest-substring-without-repeating', title: 'Longest Substring Without Repeating Characters', difficulty: 'medium', topics: ['String', 'Sliding Window'], prompt: 'Given a string s, find the length of the longest substring without repeating characters.', constraints: ['0 <= s.length <= 5 * 10^4'], examples: [{ input: 's = "abcabcbb"', output: '3' }], hints: ['Sliding window with HashSet', 'Track char positions'], starterCode: [{ language: 'javascript', functionName: 'lengthOfLongestSubstring', code: 'function lengthOfLongestSubstring(s) {\\n  return 0;\\n}\\n\\nmodule.exports = lengthOfLongestSubstring;' }, { language: 'typescript', functionName: 'lengthOfLongestSubstring', code: 'function lengthOfLongestSubstring(s: string): number {\\n  return 0;\\n}\\n\\nexport default lengthOfLongestSubstring;' }, { language: 'python', functionName: 'lengthOfLongestSubstring', code: 'def lengthOfLongestSubstring(s):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { s: 'abcabcbb' }, output: 3 }], solution: 'Sliding window: move left when duplicate found.' },
  { id: 'minimum-window-substring', slug: 'minimum-window-substring', title: 'Minimum Window Substring', difficulty: 'hard', topics: ['String', 'Sliding Window'], prompt: 'Given two strings s and t, return the minimum window substring of s such that every character in t is included in the window.', constraints: ['m == s.length', 'n == t.length'], examples: [{ input: 's = "ADOBECODEBANC", t = "ABC"', output: '"BANC"' }], hints: ['Sliding window with two pointers', 'Track char frequencies'], starterCode: [{ language: 'javascript', functionName: 'minWindow', code: 'function minWindow(s, t) {\\n  return "";\\n}\\n\\nmodule.exports = minWindow;' }, { language: 'typescript', functionName: 'minWindow', code: 'function minWindow(s: string, t: string): string {\\n  return "";\\n}\\n\\nexport default minWindow;' }, { language: 'python', functionName: 'minWindow', code: 'def minWindow(s, t):\\n    return ""' }], tests: [{ id: 's1', type: 'sample', input: { s: 'ADOBECODEBANC', t: 'ABC' }, output: 'BANC' }], solution: 'Sliding window: expand right, contract left when valid.' },
  { id: 'sliding-window-maximum', slug: 'sliding-window-maximum', title: 'Sliding Window Maximum', difficulty: 'hard', topics: ['Array', 'Sliding Window', 'Heap'], prompt: 'Given an array nums and sliding window of size k, return the max sliding window.', constraints: ['1 <= nums.length <= 10^5'], examples: [{ input: 'nums = [1,3,-1,-3,5,3,6,7], k = 3', output: '[3,3,5,5,6,7]' }], hints: ['Use deque to track indices', 'Keep deque decreasing'], starterCode: [{ language: 'javascript', functionName: 'maxSlidingWindow', code: 'function maxSlidingWindow(nums, k) {\\n  return [];\\n}\\n\\nmodule.exports = maxSlidingWindow;' }, { language: 'typescript', functionName: 'maxSlidingWindow', code: 'function maxSlidingWindow(nums: number[], k: number): number[] {\\n  return [];\\n}\\n\\nexport default maxSlidingWindow;' }, { language: 'python', functionName: 'maxSlidingWindow', code: 'def maxSlidingWindow(nums, k):\\n    return []' }], tests: [{ id: 's1', type: 'sample', input: { nums: [1,3,-1,-3,5,3,6,7], k: 3 }, output: [3,3,5,5,6,7] }], solution: 'Deque: maintain decreasing order, front is max.' },
  { id: 'longest-palindromic-substring', slug: 'longest-palindromic-substring', title: 'Longest Palindromic Substring', difficulty: 'medium', topics: ['String', 'DP'], prompt: 'Given a string s, return the longest palindromic substring in s.', constraints: ['1 <= s.length <= 1000'], examples: [{ input: 's = "babad"', output: '"bab"' }], hints: ['Expand around center', 'Or DP: dp[i][j] = is s[i:j+1] palindrome'], starterCode: [{ language: 'javascript', functionName: 'longestPalindrome', code: 'function longestPalindrome(s) {\\n  return "";\\n}\\n\\nmodule.exports = longestPalindrome;' }, { language: 'typescript', functionName: 'longestPalindrome', code: 'function longestPalindrome(s: string): string {\\n  return "";\\n}\\n\\nexport default longestPalindrome;' }, { language: 'python', functionName: 'longestPalindrome', code: 'def longestPalindrome(s):\\n    return ""' }], tests: [{ id: 's1', type: 'sample', input: { s: 'babad' }, output: 'bab' }], solution: 'Expand around each center (odd/even length).' },
  { id: 'group-anagrams', slug: 'group-anagrams', title: 'Group Anagrams', difficulty: 'medium', topics: ['String', 'Hash Table'], prompt: 'Given an array of strings strs, group the anagrams together.', constraints: ['1 <= strs.length <= 10^4'], examples: [{ input: 'strs = ["eat","tea","tan","ate","nat","bat"]', output: '[["bat"],["nat","tan"],["ate","eat","tea"]]' }], hints: ['Use sorted string as key', 'Or char count as key'], starterCode: [{ language: 'javascript', functionName: 'groupAnagrams', code: 'function groupAnagrams(strs) {\\n  return [];\\n}\\n\\nmodule.exports = groupAnagrams;' }, { language: 'typescript', functionName: 'groupAnagrams', code: 'function groupAnagrams(strs: string[]): string[][] {\\n  return [];\\n}\\n\\nexport default groupAnagrams;' }, { language: 'python', functionName: 'groupAnagrams', code: 'def groupAnagrams(strs):\\n    return []' }], tests: [{ id: 's1', type: 'sample', input: { strs: ['eat','tea','tan','ate','nat','bat'] }, output: [['bat'],['nat','tan'],['ate','eat','tea']] }], solution: 'HashMap with sorted string as key.' },
  { id: 'valid-parentheses', slug: 'valid-parentheses', title: 'Valid Parentheses', difficulty: 'easy', topics: ['String', 'Stack'], prompt: 'Given a string s containing just the characters (),{},[], determine if the input string is valid.', constraints: ['1 <= s.length <= 10^4'], examples: [{ input: 's = "()"', output: 'true' }], hints: ['Use stack', 'Push opening, pop on closing'], starterCode: [{ language: 'javascript', functionName: 'isValid', code: 'function isValid(s) {\\n  return false;\\n}\\n\\nmodule.exports = isValid;' }, { language: 'typescript', functionName: 'isValid', code: 'function isValid(s: string): boolean {\\n  return false;\\n}\\n\\nexport default isValid;' }, { language: 'python', functionName: 'isValid', code: 'def isValid(s):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { s: '()' }, output: true }], solution: 'Stack: push opening brackets, pop and match closing.' },
  { id: 'regular-expression-matching', slug: 'regular-expression-matching', title: 'Regular Expression Matching', difficulty: 'hard', topics: ['String', 'DP'], prompt: 'Given an input string s and a pattern p, implement regular expression matching with support for . and *.', constraints: ['1 <= s.length <= 20'], examples: [{ input: 's = "aa", p = "a*"', output: 'true' }], hints: ['DP: dp[i][j] = does s[0:i] match p[0:j]'], starterCode: [{ language: 'javascript', functionName: 'isMatch', code: 'function isMatch(s, p) {\\n  return false;\\n}\\n\\nmodule.exports = isMatch;' }, { language: 'typescript', functionName: 'isMatch', code: 'function isMatch(s: string, p: string): boolean {\\n  return false;\\n}\\n\\nexport default isMatch;' }, { language: 'python', functionName: 'isMatch', code: 'def isMatch(s, p):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { s: 'aa', p: 'a*' }, output: true }], solution: 'DP: handle . and * cases.' },
  { id: 'wildcard-matching', slug: 'wildcard-matching', title: 'Wildcard Matching', difficulty: 'hard', topics: ['String', 'DP'], prompt: 'Given an input string s and a pattern p, implement wildcard pattern matching with support for ? and *.', constraints: ['0 <= s.length, p.length <= 2000'], examples: [{ input: 's = "aa", p = "*"', output: 'true' }], hints: ['DP or greedy with backtracking'], starterCode: [{ language: 'javascript', functionName: 'isMatch', code: 'function isMatch(s, p) {\\n  return false;\\n}\\n\\nmodule.exports = isMatch;' }, { language: 'typescript', functionName: 'isMatch', code: 'function isMatch(s: string, p: string): boolean {\\n  return false;\\n}\\n\\nexport default isMatch;' }, { language: 'python', functionName: 'isMatch', code: 'def isMatch(s, p):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { s: 'aa', p: '*' }, output: true }], solution: 'DP or greedy matching with * backtracking.' },
  { id: 'longest-common-subsequence', slug: 'longest-common-subsequence', title: 'Longest Common Subsequence', difficulty: 'medium', topics: ['String', 'DP'], prompt: 'Given two strings text1 and text2, return the length of their longest common subsequence.', constraints: ['1 <= text1.length, text2.length <= 1000'], examples: [{ input: 'text1 = "abcde", text2 = "ace"', output: '3' }], hints: ['DP: dp[i][j] = LCS of text1[0:i] and text2[0:j]'], starterCode: [{ language: 'javascript', functionName: 'longestCommonSubsequence', code: 'function longestCommonSubsequence(text1, text2) {\\n  return 0;\\n}\\n\\nmodule.exports = longestCommonSubsequence;' }, { language: 'typescript', functionName: 'longestCommonSubsequence', code: 'function longestCommonSubsequence(text1: string, text2: string): number {\\n  return 0;\\n}\\n\\nexport default longestCommonSubsequence;' }, { language: 'python', functionName: 'longestCommonSubsequence', code: 'def longestCommonSubsequence(text1, text2):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { text1: 'abcde', text2: 'ace' }, output: 3 }], solution: 'DP: if chars match, dp[i][j]=1+dp[i-1][j-1], else max(dp[i-1][j], dp[i][j-1]).' },
  { id: 'distinct-subsequences', slug: 'distinct-subsequences', title: 'Distinct Subsequences', difficulty: 'hard', topics: ['String', 'DP'], prompt: 'Given two strings s and t, return the number of distinct subsequences of s which equals t.', constraints: ['1 <= s.length, t.length <= 1000'], examples: [{ input: 's = "rabbbit", t = "rabbit"', output: '3' }], hints: ['DP: dp[i][j] = count of t[0:j] in s[0:i]'], starterCode: [{ language: 'javascript', functionName: 'numDistinct', code: 'function numDistinct(s, t) {\\n  return 0;\\n}\\n\\nmodule.exports = numDistinct;' }, { language: 'typescript', functionName: 'numDistinct', code: 'function numDistinct(s: string, t: string): number {\\n  return 0;\\n}\\n\\nexport default numDistinct;' }, { language: 'python', functionName: 'numDistinct', code: 'def numDistinct(s, t):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { s: 'rabbbit', t: 'rabbit' }, output: 3 }], solution: 'DP: if s[i]==t[j], dp[i][j]=dp[i-1][j-1]+dp[i-1][j], else dp[i-1][j].' },
  { id: 'interleaving-string', slug: 'interleaving-string', title: 'Interleaving String', difficulty: 'medium', topics: ['String', 'DP'], prompt: 'Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.', constraints: ['0 <= s1.length, s2.length <= 100'], examples: [{ input: 's1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"', output: 'true' }], hints: ['DP: dp[i][j] = can s3[0:i+j] be formed from s1[0:i] and s2[0:j]'], starterCode: [{ language: 'javascript', functionName: 'isInterleave', code: 'function isInterleave(s1, s2, s3) {\\n  return false;\\n}\\n\\nmodule.exports = isInterleave;' }, { language: 'typescript', functionName: 'isInterleave', code: 'function isInterleave(s1: string, s2: string, s3: string): boolean {\\n  return false;\\n}\\n\\nexport default isInterleave;' }, { language: 'python', functionName: 'isInterleave', code: 'def isInterleave(s1, s2, s3):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { s1: 'aabcc', s2: 'dbbca', s3: 'aadbbcbcac' }, output: true }], solution: 'DP: check if s3[i+j-1] matches s1[i-1] or s2[j-1].' },
  { id: 'scramble-string', slug: 'scramble-string', title: 'Scramble String', difficulty: 'hard', topics: ['String', 'DP'], prompt: 'Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1.', constraints: ['s1.length == s2.length'], examples: [{ input: 's1 = "great", s2 = "rgeat"', output: 'true' }], hints: ['Recursion with memoization', 'Try all split points'], starterCode: [{ language: 'javascript', functionName: 'isScramble', code: 'function isScramble(s1, s2) {\\n  return false;\\n}\\n\\nmodule.exports = isScramble;' }, { language: 'typescript', functionName: 'isScramble', code: 'function isScramble(s1: string, s2: string): boolean {\\n  return false;\\n}\\n\\nexport default isScramble;' }, { language: 'python', functionName: 'isScramble', code: 'def isScramble(s1, s2):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { s1: 'great', s2: 'rgeat' }, output: true }], solution: 'Recursion: try all split points, check if scrambled.' },
  { id: 'course-schedule-ii', slug: 'course-schedule-ii', title: 'Course Schedule II', difficulty: 'medium', topics: ['Graph', 'Topological Sort'], prompt: 'Return the ordering of courses you should take to finish all courses.', constraints: ['1 <= numCourses <= 2000'], examples: [{ input: 'numCourses = 2, prerequisites = [[1,0]]', output: '[0,1]' }], hints: ['Topological sort with DFS or Kahn'], starterCode: [{ language: 'javascript', functionName: 'findOrder', code: 'function findOrder(numCourses, prerequisites) {\\n  return [];\\n}\\n\\nmodule.exports = findOrder;' }, { language: 'typescript', functionName: 'findOrder', code: 'function findOrder(numCourses: number, prerequisites: number[][]): number[] {\\n  return [];\\n}\\n\\nexport default findOrder;' }, { language: 'python', functionName: 'findOrder', code: 'def findOrder(numCourses, prerequisites):\\n    return []' }], tests: [{ id: 's1', type: 'sample', input: { numCourses: 2, prerequisites: [[1,0]] }, output: [0,1] }], solution: 'Topological sort: return order if no cycle.' },
  { id: 'word-search-ii', slug: 'word-search-ii', title: 'Word Search II', difficulty: 'hard', topics: ['Array', 'Backtracking', 'Trie'], prompt: 'Given an m x n board and a list of words, return all words on the board.', constraints: ['m == board.length'], examples: [{ input: 'board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]', output: '["eat","oath"]' }], hints: ['Build Trie from words', 'DFS with Trie'], starterCode: [{ language: 'javascript', functionName: 'findWords', code: 'function findWords(board, words) {\\n  return [];\\n}\\n\\nmodule.exports = findWords;' }, { language: 'typescript', functionName: 'findWords', code: 'function findWords(board: string[][], words: string[]): string[] {\\n  return [];\\n}\\n\\nexport default findWords;' }, { language: 'python', functionName: 'findWords', code: 'def findWords(board, words):\\n    return []' }], tests: [{ id: 's1', type: 'sample', input: { board: [['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']], words: ['oath','pea','eat','rain'] }, output: ['eat','oath'] }], solution: 'Trie + DFS backtracking.' },
  { id: 'surrounded-regions', slug: 'surrounded-regions', title: 'Surrounded Regions', difficulty: 'medium', topics: ['Array', 'DFS', 'BFS'], prompt: 'Given an m x n matrix board containing X and O, capture all regions that are 4-directionally surrounded by X.', constraints: ['m == board.length'], examples: [{ input: 'board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]', output: '[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]' }], hints: ['DFS from border Os', 'Mark them as safe'], starterCode: [{ language: 'javascript', functionName: 'solve', code: 'function solve(board) {\\n  // Modify board in-place\\n}\\n\\nmodule.exports = solve;' }, { language: 'typescript', functionName: 'solve', code: 'function solve(board: string[][]): void {\\n  // Modify board in-place\\n}\\n\\nexport default solve;' }, { language: 'python', functionName: 'solve', code: 'def solve(board):\\n    pass' }], tests: [{ id: 's1', type: 'sample', input: { board: [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']] }, output: [['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']] }], solution: 'DFS from border Os, mark as safe, flip others.' },
  { id: 'pacific-atlantic-water-flow', slug: 'pacific-atlantic-water-flow', title: 'Pacific Atlantic Water Flow', difficulty: 'medium', topics: ['Array', 'DFS', 'BFS'], prompt: 'Given an m x n matrix of heights, return coordinates that can flow to both Pacific and Atlantic oceans.', constraints: ['m == heights.length'], examples: [{ input: 'heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]', output: '[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]' }], hints: ['DFS from Pacific border', 'DFS from Atlantic border', 'Find intersection'], starterCode: [{ language: 'javascript', functionName: 'pacificAtlantic', code: 'function pacificAtlantic(heights) {\\n  return [];\\n}\\n\\nmodule.exports = pacificAtlantic;' }, { language: 'typescript', functionName: 'pacificAtlantic', code: 'function pacificAtlantic(heights: number[][]): number[][] {\\n  return [];\\n}\\n\\nexport default pacificAtlantic;' }, { language: 'python', functionName: 'pacificAtlantic', code: 'def pacificAtlantic(heights):\\n    return []' }], tests: [{ id: 's1', type: 'sample', input: { heights: [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] }, output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]] }], solution: 'DFS from both oceans, find cells reachable from both.' },
  { id: 'graph-valid-tree', slug: 'graph-valid-tree', title: 'Graph Valid Tree', difficulty: 'medium', topics: ['Graph', 'DFS', 'BFS'], prompt: 'Given n nodes labeled from 0 to n-1 and a list of undirected edges, check if these edges make up a valid tree.', constraints: ['1 <= n <= 2000'], examples: [{ input: 'n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]', output: 'true' }], hints: ['Tree has n-1 edges', 'No cycles', 'All nodes connected'], starterCode: [{ language: 'javascript', functionName: 'validTree', code: 'function validTree(n, edges) {\\n  return false;\\n}\\n\\nmodule.exports = validTree;' }, { language: 'typescript', functionName: 'validTree', code: 'function validTree(n: number, edges: number[][]): boolean {\\n  return false;\\n}\\n\\nexport default validTree;' }, { language: 'python', functionName: 'validTree', code: 'def validTree(n, edges):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { n: 5, edges: [[0,1],[0,2],[0,3],[1,4]] }, output: true }], solution: 'Check: edges.length == n-1, no cycles (DFS), all connected.' },
  { id: 'find-peak-element', slug: 'find-peak-element', title: 'Find Peak Element', difficulty: 'medium', topics: ['Array', 'Binary Search'], prompt: 'A peak element is an element that is strictly greater than its neighbors. Find a peak element and return its index.', constraints: ['1 <= nums.length <= 1000'], examples: [{ input: 'nums = [1,2,3,1]', output: '2' }], hints: ['Binary search', 'Move towards higher neighbor'], starterCode: [{ language: 'javascript', functionName: 'findPeakElement', code: 'function findPeakElement(nums) {\\n  return 0;\\n}\\n\\nmodule.exports = findPeakElement;' }, { language: 'typescript', functionName: 'findPeakElement', code: 'function findPeakElement(nums: number[]): number {\\n  return 0;\\n}\\n\\nexport default findPeakElement;' }, { language: 'python', functionName: 'findPeakElement', code: 'def findPeakElement(nums):\\n    return 0' }], tests: [{ id: 's1', type: 'sample', input: { nums: [1,2,3,1] }, output: 2 }], solution: 'Binary search: if nums[mid] < nums[mid+1], search right, else left.' },
  { id: 'search-in-rotated-sorted-array-ii', slug: 'search-in-rotated-sorted-array-ii', title: 'Search in Rotated Sorted Array II', difficulty: 'medium', topics: ['Array', 'Binary Search'], prompt: 'Given the array nums after rotation and an integer target, return true if target is in nums, or false otherwise. Array may contain duplicates.', constraints: ['1 <= nums.length <= 5000'], examples: [{ input: 'nums = [2,5,6,0,0,1,2], target = 0', output: 'true' }], hints: ['Binary search with duplicate handling', 'Skip duplicates at boundaries'], starterCode: [{ language: 'javascript', functionName: 'search', code: 'function search(nums, target) {\\n  return false;\\n}\\n\\nmodule.exports = search;' }, { language: 'typescript', functionName: 'search', code: 'function search(nums: number[], target: number): boolean {\\n  return false;\\n}\\n\\nexport default search;' }, { language: 'python', functionName: 'search', code: 'def search(nums, target):\\n    return False' }], tests: [{ id: 's1', type: 'sample', input: { nums: [2,5,6,0,0,1,2], target: 0 }, output: true }], solution: 'Binary search: handle duplicates by incrementing left when nums[left]==nums[mid].' }
];

'''

# Write back
with open('/home/wasim/Quiz App/CodeToCareer/data/practice/problems.ts', 'w') as f:
    f.write(content + final_problems)

print("Successfully added 28 problems! Total: 150")
